name: Release
on:
    workflow_call:
        secrets:
            githubAccessToken:
                required: true
        inputs:
            pipelineType:
                description: Pipeline Type
                default: release
                type: string
                required: false
            releaseType:
                description: Release Type
                default: patch
                type: string
                required: false

env:
    uniqueWorkspaceId: /u/github/workspace/${{ github.repository }}/${{ github.ref_name }}/build_r${{github.run_number }} # adding an r to before the number,
    # to avoid an error caused by repeated build numbers 
    buildIdentifier: build_r${{github.run_number}} 
    branch : ${{ github.ref_name }} 
    application: ${{  github.event.repository.name  }}
    pipelineType: ${{ inputs.pipelineType }}
    packageName: ${{github.run_id}}
    zosHostname: lpar.dev.ibm.com
    zosSFTPUser: GITHUB@lpar.dev.ibm.com
    nextReleaseVersion: ""

jobs:
    Setup:
        runs-on: self-hosted
        steps:
          - name: CI-CD pipeline parameter printout
            run: |
                echo " "
                echo "Following are the CI-CD pipeline parameters"
                echo "*******************************************"
                echo "uniqueWorkspaceId                  = ${{ env.uniqueWorkspaceId}}"
                echo "buildIdentifier                    = ${{ env.buildIdentifier}}"
                echo "branch                             = ${{ env.branch}}"
                echo "application                        = ${{ env.application}}"
                echo "pipelineType                       = ${{ env.pipelineType}}"
                echo "packageName                        = ${{ env.packageName}}"
                echo "zosHostname                        = ${{ env.zosHostname}}"
                echo "zosSFTPUser                        = ${{ env.zosSFTPUser}}"

          - name: Clone Repo to z/OS Unix System Services
            run: ssh ${{ env.zosSFTPUser}} ". ./.profile && gitClone.sh -w ${{ env.uniqueWorkspaceId }} -r https://${{ secrets.githubAccessToken }}@github.com/${{ github.repository }}.git -b ${{ env.branch }}" 

    Build:
        needs:
            - Setup
        runs-on: self-hosted
        steps:
          - name: Build git repo
            run: ssh ${{ env.zosSFTPUser}} ". ./.profile && dbbBuild.sh -w ${{ env.uniqueWorkspaceId }} -a ${{env.application}} -b ${{ env.branch }} -p ${{env.pipelineType}}"
          
          - name: Prepare Logs
            if: ${{ always() }}
            run: |
                ssh ${{ env.zosSFTPUser}} ". ./.profile && prepareLogs.sh -w ${{ env.uniqueWorkspaceId }}"  
                rm -rf "${{ runner.temp }}/build-logs" 
                mkdir "${{ runner.temp }}/build-logs" 
                sftp ${{ env.zosSFTPUser}}:${{ env.uniqueWorkspaceId }}/*.tar "\"${{ runner.temp }}/build-logs\""
                tar -xvf "${{ runner.temp }}/build-logs/logs.tar" -C "${{ runner.temp }}/build-logs"

          - name: UploadBuildLogs
            uses: actions/upload-artifact@v4
            with:
              name: build_${{github.run_number }}                        # Name used for artifact when it is uploaded
              path: ${{ runner.temp }}/build-logs                        # Path to build logs artifacts
              retention-days: 1
          
          - name: checkout
            uses: actions/checkout@v4.1.0
            with:
                fetch-depth: 0
            
          - name: Create Release Candidate Tag
            if: success() && env.pipelineType == 'release'
            run: |
              ssh ${{ env.zosSFTPUser}} ". ./.profile && computeReleaseVersion.sh -w ${{ env.uniqueWorkspaceId}} -a ${{ env.application }} -b ${{ env.branch }} -r ${{ inputs.releaseType }} "  > "${{ runner.temp }}/computeNextReleaseVersion.log"
              cat "${{ runner.temp }}/computeNextReleaseVersion.log" 
              nextReleaseVersion=$(cat "${{ runner.temp }}/computeNextReleaseVersion.log" | sed  -n 's/.*The next release version: \(rel-[0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p')
              #Check nextReleaseVersion variable retrieved by sed
              rc=0
              if [ $rc -eq 0 ]; then
                if [ -z "${nextReleaseVersion}" ]; then
                  rc=8
                  ERRMSG="[ERROR] The name of the next release could not be parsed. Check stage and ${{ runner.temp }}/computeNextReleaseVersion.log on the GH actions runner environment. rc="$rc
                  echo "$ERRMSG"
                else
                  echo "[INFO] Retrieved next release version: $nextReleaseVersion"
                  gh release create ${nextReleaseVersion}-${{env.buildIdentifier}} --prerelease 
                fi
              fi
              echo "${nextReleaseVersion}" > releaseTag.txt

          - name: Upload version tag artifact
            uses: actions/upload-artifact@v4
            with:
              name: artifactVersion
              path: releaseTag.txt 

    Package:
        needs:
            - Build
        runs-on: self-hosted
        steps:
            - name: Package Build Outputs
              run: |
                ssh ${{ env.zosSFTPUser}} ". ./.profile && computeReleaseVersion.sh -w ${{ env.uniqueWorkspaceId}} -a ${{ env.application }} -b ${{ env.branch }} -r ${{ inputs.releaseType }} "  > "${{ runner.temp }}/computeNextReleaseVersion.log"
                cat "${{ runner.temp }}/computeNextReleaseVersion.log" 
                nextReleaseVersion=$(cat "${{ runner.temp }}/computeNextReleaseVersion.log" | sed  -n 's/.*The next release version: \(rel-[0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p')
                #Check nextReleaseVersion variable retrieved by sed
                rc=0
                if [ $rc -eq 0 ]; then
                  if [ -z "${nextReleaseVersion}" ]; then
                    rc=8
                    ERRMSG="[ERROR] The name of the next release could not be parsed. Check stage and ${{ runner.temp }}/computeNextReleaseVersion.log on the GH actions runner environment. rc="$rc
                    echo "$ERRMSG"
                  else
                    echo "[INFO] Retrieved next release version: $nextReleaseVersion"
                    ssh ${{ env.zosSFTPUser}} ". ./.profile && packageBuildOutputs.sh -w ${{ env.uniqueWorkspaceId }} -t ${{ env.application }} -a ${{ env.application }} -b release -p ${{env.pipelineType}} -r ${nextReleaseVersion} -i ${{ env.buildIdentifier}}"
                  fi
                fi

    Deploy-Integration:
        needs: Package
        runs-on: self-hosted
        steps:
          - name: Generate deployment plan with Wazi Deploy
            run: |
              ssh ${{ env.zosSFTPUser}} ". ./.profile && computeReleaseVersion.sh -w ${{ env.uniqueWorkspaceId}} -a ${{ env.application }} -b ${{ env.branch }} -r ${{ inputs.releaseType }} "  > "${{ runner.temp }}/computeNextReleaseVersion.log"
              cat "${{ runner.temp }}/computeNextReleaseVersion.log" 
              nextReleaseVersion=$(cat "${{ runner.temp }}/computeNextReleaseVersion.log" | sed  -n 's/.*The next release version: \(rel-[0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p')
              rc=0
              if [ $rc -eq 0 ]; then
                if [ -z "${nextReleaseVersion}" ]; then
                  rc=8
                  ERRMSG="[ERROR] The name of the next release could not be parsed. Check stage and ${{ runner.temp }}/computeNextReleaseVersion.log on the GH actions runner environment. rc="$rc
                  echo "$ERRMSG"
                else
                  ssh ${{ env.zosSFTPUser}} ". ./.profile && mkdir -p ${{ env.uniqueWorkspaceId }}/deployPkgDir/deploy-logs-Integration/ && wazideploy-generate.sh -w ${{ env.uniqueWorkspaceId }} -a ${{env.application}} -P ${{env.pipelineType}} -R ${nextReleaseVersion} -I ${{env.buildIdentifier}} -b ${{ env.branch }}"
                fi
              fi
          
          - name: Deploy package with Wazi Deploy
            run: ssh ${{ env.zosSFTPUser}} ". ./.profile && wazideploy-deploy.sh -w ${{ env.uniqueWorkspaceId }} -e EOLEB7-${{ env.application }}-Integration.yaml -i ${{ env.application }}-${{ env.buildIdentifier}}.tar -l deploy-logs-Integration/evidences/evidence.yaml"

          - name: Generate deployment report with Wazi Deploy
            run: ssh ${{ env.zosSFTPUser}} ". ./.profile && wazideploy-evidence.sh -w ${{ env.uniqueWorkspaceId }} -l deploy-logs-Integration/evidence.yaml -o deploy-logs-Integration/deployment-report.html"

          - name: Retrieve deployment reports
            run: |
              rm -rf "${{ runner.temp }}/deploy-logs-Integration/"
              mkdir "${{ runner.temp }}/deploy-logs-Integration/"
              sftp -r ${{ env.zosSFTPUser}}:${{ env.uniqueWorkspaceId }}/deployPkgDir/deploy-logs-Integration/* "\"${{ runner.temp }}/deploy-logs-Integration\""

          - name: Publish deployment logs
            uses: actions/upload-artifact@v4.0.0
            with:
              path: "${{ runner.temp }}/deploy-logs-Integration/"
              name: "artifact-Integration"
        
          - name: Create Wazi Deploy Index
            uses: "./.github/actions/createwazideployindex"
            with:
              evidenceFolder: deploy-logs-Integration
              environmentName: Integration
              buildNumber: ${{github.run_number }} 
              zosSFTPUser: ${{ env.zosSFTPUser}}

          - name: Create production release tag        
            uses: "./.github/actions/tagging_createproductionreleasetag"
            with:
              environmentName: Integration
              releaseType: "${{ inputs.releaseType }}"
              githubAccessToken: ${{ secrets.githubAccessToken }} 

    Cleanup:
        needs:
            - Deploy-Integration
        runs-on: self-hosted
        if: always()
        steps:
          - name: Cleanup Build Environment
            run: ssh ${{ env.zosSFTPUser}} ". ./.profile && deleteWorkspace.sh -w ${{ env.uniqueWorkspaceId }}"
